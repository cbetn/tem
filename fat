#GREAPH VISUALALIZER

import networkx as nx
import matplotlib.pyplot as plt

class GraphVisualizer:
    def __init__(
        self,
        edges, 
        pos=None,
        weighted=None,
        solution_edges=None,
        is_solution_directed=False,
    ):
        self.graph = nx.Graph()
        self.weighted = weighted
        self.solution_edges = solution_edges
        self.is_solution_directed = is_solution_directed
        if weighted is None:
            self.graph.add_edges_from(edges)
        else:
            self.graph.add_weighted_edges_from(edges)
        self.pos = (
            pos if pos else nx.spring_layout(self.graph)
        )  # Use provided position or generate new

    def draw_graph(self, title="Graph", save_path=None):
        plt.figure(figsize=(6, 4))
        nx.draw(
            self.graph,
            self.pos,
            with_labels=True,
            node_color="lightblue",
            edge_color="gray",
            node_size=500,
            font_size=10,
        )

        if self.weighted is not None:
            edge_labels = {
                (u, v): d["weight"] for u, v, d in self.graph.edges(data=True)
            }
            nx.draw_networkx_edge_labels(self.graph, self.pos, edge_labels=edge_labels)

        if self.solution_edges:
            nx.draw_networkx_edges(
                self.graph,
                pos=self.pos,
                edgelist=self.solution_edges,
                edge_color="green",
                width=4,
                arrows=self.is_solution_directed,
                arrowstyle="->",
                arrowsize=20,
                connectionstyle="arc3,rad=0.2",
            )

        plt.title(title)

        if save_path:
            plt.savefig(save_path)  # Save the figure if a path is provided
        else:
            plt.show()





#BFS

from collections import deque
import pandas as pd
import networkx as nx
from itertools import combinations
from graph_visualizer import GraphVisualizer


# ---------- Node class ----------
class Node:
    def __init__(self, state, parent=None):
        self.STATE = state
        self.PARENT = parent

    def __str__(self):
        return f"{self.STATE}"


# ---------- Helper functions ----------
def GOAL_TEST(node, goal):
    return node.STATE == goal


def SOLUTION(node):
    path = []
    while node:
        path.append(node.STATE)
        node = node.PARENT
    return list(reversed(path))


# ---------- BFS for shortest collaboration path ----------
def BFS(G, start, goal):
    """
    Finds the shortest collaboration path between two departments using BFS.
    """
    node = Node(start, parent=None)
    frontier = deque([node])
    explored = set()

    while frontier:
        node = frontier.popleft()
        explored.add(node.STATE)

        if GOAL_TEST(node, goal):
            return SOLUTION(node)

        for neighbor in G.neighbors(node.STATE):
            if neighbor not in explored and all(neighbor != n.STATE for n in frontier):
                frontier.append(Node(state=neighbor, parent=node))
    return None


# ---------- Build Collaboration Graph from CSV ----------
def build_collaboration_graph(csv_path="department_project.csv"):
    df = pd.read_csv(csv_path)
    G = nx.Graph()

    # Add edges between departments that share a project
    for project, group in df.groupby('Project'):
        departments = list(group['Department'])
        for dept1, dept2 in combinations(departments, 2):
            G.add_edge(dept1, dept2, project=project)
    return G


# ---------- Main Execution ----------
if __name__ == "__main__":
    # Build the collaboration graph
    G = build_collaboration_graph("department_project.csv")

    # Show adjacency list
    adj_list = {dept: list(G.neighbors(dept)) for dept in G.nodes()}
    print("Adjacency List Representation:")
    for dept, neighbors in adj_list.items():
        print(f"{dept}: {neighbors}")

    # Select start and goal departments
    start_dept = "HR"
    goal_dept = "Engineering"

    # Find the shortest collaboration path
    solution = BFS(G, start=start_dept, goal=goal_dept)
    print("\nShortest Collaboration Path:")
    if solution:
        print(" → ".join(solution))
    else:
        print("No path found between the departments.")

    # ---------- Visualization ----------
    pos = nx.spring_layout(G, seed=42)
    path_edges = list(zip(solution, solution[1:])) if solution else []

    graph = GraphVisualizer(
        edges=G.edges,
        pos=pos,
        weighted=None,
        solution_edges=path_edges,
        is_solution_directed=False
    )

    graph.draw_graph(title=f"Collaboration Network: {start_dept} → {goal_dept}")







#DFS :

# department_dfs_analysis.py
import pandas as pd
import networkx as nx
import random
from graph_visualizer import GraphVisualizer


# ---------- Node class ----------
class Node:
    def __init__(self, state, parent=None):
        self.STATE = state
        self.PARENT = parent

    def __str__(self):
        return f"{self.STATE}"


# ---------- Basic DFS ----------
def GOAL_TEST(node, goal):
    return node.STATE == goal


def CHILD_NODES(node, G):
    """Return child departments supervised by the current node."""
    children = []
    for neighbor in G.neighbors(node.STATE):
        children.append(Node(state=neighbor, parent=node))
    return children


def SOLUTION(node):
    """Trace path from goal to start."""
    path = []
    while node:
        path.append(node.STATE)
        node = node.PARENT
    return list(reversed(path))


def DFS(G, start, goal):
    """(a) Find a path between departments using DFS."""
    node = Node(start, parent=None)
    frontier = [node]
    explored = set()

    while frontier:
        node = frontier.pop()
        explored.add(node.STATE)

        if GOAL_TEST(node, goal):
            return SOLUTION(node)

        for child in reversed(CHILD_NODES(node, G)):
            if (child.STATE not in explored) and all(child.STATE != n.STATE for n in frontier):
                frontier.append(child)
    return None


# ---------- (b) DFS for Maximum Priority Path ----------
def dfs_max_priority(G, start, goal):
    """Find path with maximum cumulative priority using DFS."""
    best_path = []
    best_priority = 0

    def dfs_recursive(node, path, total_priority):
        nonlocal best_path, best_priority

        path.append(node)
        total_priority += G.nodes[node]["priority"]

        if node == goal:
            if total_priority > best_priority:
                best_priority = total_priority
                best_path = path.copy()
        else:
            for neighbor in G.neighbors(node):
                if neighbor not in path:
                    dfs_recursive(neighbor, path, total_priority)

        path.pop()

    dfs_recursive(start, [], 0)
    return best_path, best_priority


# ---------- (c) Count Reachable Sub-Departments ----------
def reachable_departments(G, start):
    visited = set()
    stack = [start]

    while stack:
        dept = stack.pop()
        if dept not in visited:
            visited.add(dept)
            stack.extend(G.neighbors(dept))
    return len(visited) - 1  # exclude the start department itself


# ---------- (e) Cycle Detection ----------
def detect_cycle(G):
    """Detect cycles in the directed hierarchy graph."""
    try:
        nx.find_cycle(G, orientation="original")
        return True
    except nx.NetworkXNoCycle:
        return False


# ---------- MAIN EXECUTION ----------
if __name__ == "__main__":
    # Load department hierarchy dataset
    df = pd.read_csv("department_hierarchy.csv")

    # Create a directed graph (Parent → Sub-Department)
    G = nx.DiGraph()
    for _, row in df.iterrows():
        G.add_edge(row["Parent_Department"], row["Sub_Department"])

    # Assign random priority to each department (1–10)
    for node in G.nodes:
        G.nodes[node]["priority"] = random.randint(1, 10)

    start = "Executive"
    goal = "R&D"

    # (a) Normal DFS path
    path = DFS(G, start, goal)
    print(f"(a) DFS Path from {start} to {goal}:", path)

    # (b) Max priority path
    best_path, best_priority = dfs_max_priority(G, start, goal)
    print(f"(b) Max Priority Path: {best_path} with Total Priority = {best_priority}")

    # (c) Reachable sub-departments
    count = reachable_departments(G, start)
    print(f"(c) Number of reachable sub-departments from {start}: {count}")

    # (e) Cycle detection
    print(f"(e) Cycle detected in hierarchy: {detect_cycle(G)}")

    # (d) Visualization
    if path:
        path_edges = list(zip(path, path[1:]))
        pos = nx.spring_layout(G, seed=42)
        graph = GraphVisualizer(
            G.edges,
            pos=pos,
            solution_edges=path_edges,
            is_solution_directed=True,
        )
        graph.draw_graph(title=f"DFS Hierarchy Path: {start} → {goal}")

